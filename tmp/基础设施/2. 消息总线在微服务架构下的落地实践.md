

# 面向业务的消息总线设计

我们在上次分享中聊到了领域驱动设计和微服务，在 DDD 中有一个术语叫做领域事件，例如订单模型中的订单已创建、商品与发货都叫做领域事件。

领域事件会触发下一步的业务操作，如果领域事件发生在微服务内，可以通过观察者模式很容易实现消息监听并处理。

![image-20230324212257753](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303242122856.png)

如果发生在微服务之间，则需引入事件总线或者消息中间件。

## 消息队列解决方案

经过技术选型后，我们决定使用 Kafka 作为消息中间件，此时微服务间的通信示意图如下：

![image-20230324213219672](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303242132712.png)

这种接入方式需要业务服务引入 Kafka SDK 并关注 Kafka 的各种复杂繁琐的配置，不同微服务的实现有大量重复逻辑。开发成本太高了！

其次，随着订阅关系复杂，Topic 日益增多，服务之间的订阅关系变得不清晰。随着各个团队的接入使用，Topic 的创建并没有统一的规范。

我们期望的结果是，即使团队中没人了解消息队列技术，也能够收发消息。

例如，我们期望通过很简单的方式就能接入消息服务，期望通过很简单的调用，就能发送消息、接收消息。

![image-20230324214214450](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/202303242142490.png)

message-bus-client 是一个基于 Kafka SDK 封装的客户端包，主要就是为了简化消息的收发，无需关注配置。

消息队列的作用：削峰填谷、异步、解耦。

![image-20201203172036177](https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/image-20201203172036177.png)

直接使用消息队列将面临以下问题：

1. 开发成本大：开发团队成员都需要对消息队列如 Kafka 技术有一定的了解，并且还需要关注连接消息队列的一些配置；
2. 管理难度大：各团队都使用一个消息队列，其中一个团队使用不当时，例如创建了很多个 topic，造成资源浪费；
3. 监控难度大：当前只有对 Kafka 集群简单的监控功能；
4. 运维困难：遇到线上消息没有消费时，很难排查问题，无从下手；
5. 升级难度大：Kafka-Client 需要升级时，涉及到服务太多，导致升级成本高；

使用消息队列，那对团队的要求是至少要有一个人对这项技术有所了解，这其实是一种面向技术的架构。而我们期望提供的解决方案是一种以业务为重心的，面向服务的架构。

既然是面向业务，那就要尽可能地满足让业务方满意。

比如业务方监听消息，执行一系列的业务逻辑异常了，想要做业务补偿。

## 消息服务解决方案

### 架构设计

面对上面问题，采用消息总线服务的方式进行优化。

![image-20230218150647472](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230218150647472.png)

消息服务隐藏了消息发送、必送必达、路由、分组、过滤、存储、高可用等一系列问题。

### 消息流转过程

![image-20230218162013959](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230218162013959.png)

## 消息服务初体验

由于我们的微服务使用的是 SpingBoot 来落地的，因此我们提供了一个接入消息总线的 spring-boot-starter。

### 零配置接入消息总线



### 消息结构定义

下面代码定义了一个消息的基本信息，也称为消息 Header，包括消息 id，分区键 primaryKey，来源服务 service，消息 topic，创建时间 timstamp。

```java
public abstract class Message {
    private String id;
    private String primaryKey;
    private String service;
    private String topic;
    private Date timeStamp;
}
```

消息可以分为两类，一类是事件，另一类是广播。定义如下：

```java
// 事件
public abstract class Event extends Message {
}
```

```java
// 广播
public abstract class Event extends Message {
}
```

业务消息内容称为消息 Body，例如订单已创建这个消息体的定义：

```java
@Topic(name = "order")
public class OrderCreated extends Event {
    private String orderId;
    private String orderName;
    private Date createdAt;
}
```



### 使收发消息变得简单

```java
// 发送消息
EventPublisher.publish(new OrderCreated());
```

```java
// 接收消息
@EventHandler(topic = "order", consumerGroup = "consumer-group1")
public class OrderMessageHandler {
    public void handle(OrderCreated orderCreated) {
        System.out.println("receive message: " + orderCreated);
    }
}
```

### 提供 5 种功能类型的消息

1、事件消息

```java
@Topic(name = "order")
public class OrderCreated extends Event {
    private String orderId;
    private String orderName;
    private Date createdAt;
}

public void send() {
    EventPublisher.publish(new OrderCreated());
}
```

上面消息定义是事件，这是使用最多的一种消息。

2、广播消息

```java
@Topic(name = "order")
public class OrderCreated extends Broadcast {
    private String orderId;
    private String orderName;
    private Date createdAt;
}

public void send() {
    EventPublisher.publish(new OrderCreated());
}
```

上面消息定义时，继承了`Broadcast`，表示这是一个广播消息，消费服务的每个节点都将会收到这个广播。

3、顺序消息

```java
@Topic(name = "order")
public class OrderCreated extends Event {
    @PrimaryKey
    private String orderId;
    private String orderName;
    private Date createdAt;
}

public void send() {
    EventPublisher.publish(new OrderCreated());
}
```

上面消息定义时，在`orderId`上加了`@PrimaryKey`注解，表示相同`orderId`的消息会有序的消费。

4、事务消息

```java
@Topic(name = "order")
public class OrderCreated extends Event {
    private String orderId;
    private String orderName;
    private Date createdAt;
}

@Transactional
public void send() {
    EventPublisher.publish(new OrderCreated());
}
```

上面消息发送时，在方法上添加了`@Transactional`注解，这是 Spring 的注解，表示这个方法里的逻辑执行是有事务性的。

5、延迟消息

```java
@Topic(name = "order")
public class OrderCreated extends Event {
    private String orderId;
    private String orderName;
    private Date createdAt;
}

@Transactional
public void send() {
    EventPublisher.publish(new OrderCreated(), 2, TimeUnit.SECONDS);
}
```

上面消息发送多了两个参数，表示延迟 2 秒接收。

### 消息追踪

只要是通过`EventPublisher.publish()`方法发送的消息，都可以追踪到这条消息记录。

发送失败：消息定义不规范，消息过大。

推送失败：

业务处理失败：



### 消息高可靠

补偿机制：失败重试、自动补偿、手动补偿。



