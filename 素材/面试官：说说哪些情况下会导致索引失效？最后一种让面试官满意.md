# 使用 OPTIMIZER_TRACE 追踪 MySQL 选择索引的过程

优化查询语句的性能是 MySQL 数据库管理中的一个重要方面。在优化查询性能时，选择正确的索引对于减少查询的响应时间和提高系统性能至关重要。但是，如何确定 MySQL 的索引选择策略？MySQL 的优化器是如何选择索引的？

为了更好地理解 MySQL 优化器的工作原理，我们可以使用一个强大的调试工具：OPTIMIZER_TRACE，它可以帮助我们追踪 MySQL 选择索引的过程，以及了解优化器在选择索引时所考虑的各种因素。

我们知道，索引区分度不高可能会导致索引失效。

- 索引中断
- 数据类型不匹配
- 查询条件使用函数操作
- 前模糊查询
- OR 查询
- 建立索引时使用函数
- 索引区分度不高



当你在使用 MySQL 进行查询时，你可能会遇到性能问题。其中一个可能的原因是，MySQL 没有使用索引，MySQL 索引是提高查询性能和效率的重要手段。但是，如果索引使用不当，甚至会导致性能问题。因此，了解索引失效的原因是十分重要的。

在这篇文章中，我们将讨论 MySQL 索引失效的各种情况。假设现在我们有一张人物表，建表语句如下：

```sql
CREATE TABLE `person` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(64) NOT NULL,
  `score` int(11) NOT NULL,
  `age` int(11) NOT NULL,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_name_score` (`name`,`score`) USING BTREE,
  KEY `idx_age` (`age`) USING BTREE,
  KEY `idx_create_time` (`create_time`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;

INSERT INTO test.person (id, name, score, age, create_time) VALUES(1, '00031', 90, 18, '2023-04-15 16:29:39');
INSERT INTO test.person (id, name, score, age, create_time) VALUES(2, '31a', 96, 19, '2023-04-15 16:29:39');
```

1、索引中断

对于联合索引 `name`,`score`，条件中如果只有 `score`，则会导致索引失效。例如：

```sql
-- 表中有 (`name`,`score`) 的联合索引
select * from person where score = 90
```

而下面的情况都会使用索引：

```sql
select * from person where name = '31a'
select * from person where score = 90 and name = '31a'
select * from person where name = '31a' and score = 90
```

2、数据类型不匹配

如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则会导致索引失效。例如：

```sql
-- 这里 name 是 varchar 类型
select * from person where name = 31
```

但是如果索引是 int 类型，而查询参数是 varchar 类型，因为字符串隐式转为数值，不存在歧义，所以会走索引。

```sql
-- 这里 age 是 int 类型
select * from person where age = '90'
```

MySQL 为什么不把 31 隐式转换字符串呢？这个问题在 [MySQL 官方文档](https://dev.mysql.com/doc/refman/8.0/en/type-conversion.html)中给出了答案。

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230415155250489.png)

针对数值1，与字符串'1', '1a', '001', '1  '等多种情况均相等，会存在歧义。不妨看个例子：

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230415163005970.png)

3、查询条件使用函数操作

如果查询条件中使用了函数操作，MySQL 将无法使用索引，需要对索引列进行函数操作，导致索引失效。例如：

```sql
-- 如果需要使用 date_column 字段的年份进行查询，那么将导致索引失效
SELECT * FROM table_name WHERE YEAR(date_column) = '2021';
```

4、前模糊查询

如果索引是前缀索引，但查询条件使用了索引列的后缀，那么 MySQL 将无法使用索引，导致索引失效。例如：

```sql
-- 如果索引是前缀索引，但查询使用了后缀，那么将导致索引失效
SELECT * FROM table_name WHERE name LIKE '%John';
```

5、OR 查询

OR 前后条件都包含索引则走索引，OR 前后有一个不包含索引索引失效。

```sql
-- 如果查询条件中同时包含索引列和非索引列，或多个非索引列之间使用 OR 操作符连接，那么将导致索引失效
SELECT * FROM table_name WHERE (name = 'John' OR age > 20) AND city = 'New York';
```

6、建立索引时使用函数

如果查询条件中使用了函数操作，即使使用了索引列，MySQL 也无法使用索引，导致索引失效。例如：

```sql
CREATE INDEX idx_name ON table_name (LOWER(name));
-- 如果使用 LOWER(name) 函数建立索引，那么下面查询将导致索引失效
SELECT * FROM table_name WHERE name = 'John';
```

7、索引区分度不高

如果索引列的值区分度不高，MySQL 可能会放弃使用索引，选择全表扫描，导致索引失效。

我先用一个具体的例子来描述一下这个场景。

## 案例场景

然后插入 10 万条数据：

```sql
create PROCEDURE `insert_person`()
begin
    declare c_id integer default 3;
    while c_id <= 100000 do
	    insert into person values(c_id, concat('name',c_id), c_id + 100, c_id + 10, date_sub(NOW(), interval c_id second));
	    -- 需要注意，因为使用的是now()，所以对于后续的例子，使用文中的SQL你需要自己调整条件，否则可能看不到文中的效果
	    set c_id = c_id + 1;
    end while;
end;
CALL insert_person();
```

可以看到，最早的 `create_time` 是 `2023-04-14 13:03:44`。

![](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230415165725653.png)

我们用下面的 SQL 进行查询：

```sql
explain select * from person where NAME>'name84059' and create_time>'2023-04-15 13:00:00'
```

![image-20230415170116366](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230415170116366.png)

通过上面的执行计划可以看到：type=All，说明是全表扫描。接着我们把 create_time 条件中的 13 点改为 15 点：

```sql
explain select * from person where NAME>'name84059' and create_time>'2023-04-15 15:00:00'
```

![image-20230415170143165](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230415170143165.png)

执行计划显示：type=range，key=create_time，走了 create_time 索引，而不是 name_score 联合索引。

看到这里，你是不是很诧异？接下来，我们就一起来分析一下这背后的原因。

## 原因分析

MySQL 在查询数据之前，会先对可能的方案做执行计划，然后依据成本决定走哪个执行计划。这里的成本，包括 IO 成本和 CPU 成本：

- IO 成本，是从磁盘把数据加载到内存的成本。默认情况下，读取数据页的 IO 成本常数是 1（也就是读取 1 个页成本是 1）。
- CPU 成本，是检测数据是否满足条件和排序等 CPU 操作的成本。默认情况下，检测记录的成本是 0.2。

MySQL 维护了表的统计信息，可以使用下面的命令查看：

```sql
SHOW TABLE STATUS LIKE 'person'
```

![image-20230415170430846](https://technotes.oss-cn-shenzhen.aliyuncs.com/2023/image-20230415170430846.png)

从图中可以看到，总行数是 100064 行，由于 MySQL 的统计信息是一个估算，这里多了 64 行是正常的。CPU 成本是 100064*0.2=20012.8 左右。

数据长度是 5783552 字节。对于 InnoDB 来说，5783552  就是聚簇索引占用的空间，等于聚簇索引的页数量 * 每个页面的大小。InnoDB 每个页面的大小是 16KB，大概计算出页的数量是 353，因此 IO 成本是 353 左右。

所以，全表扫描的总成本是 20365.8 左右。

在 MySQL 5.6 及之后的版本中，我们可以使用 optimizer trace 功能查看优化器生成执行计划的整个过程。

```sql
-- 依次执行
SET OPTIMIZER_TRACE="enabled=on",END_MARKERS_IN_JSON=on;
SET optimizer_trace_offset=-30, optimizer_trace_limit=30;
explain select * from person where NAME >'name84059';
-- explain select * from person where create_time>'2023-04-15 13:00:00';
-- explain select * from person;
select * from information_schema.OPTIMIZER_TRACE;
SET optimizer_trace="enabled=off";
```

对于按照 `create_time>'2023-04-15 13:00:00'` 条件走全表扫描的 SQL，我从 OPTIMIZER_TRACE 的执行结果中，摘出了几个重要片段来重点分析：

1. 使用 name_score 对 name84059<name 条件进行索引扫描需要扫描 26420 行，成本是 31705。

```json
{
    "index": "idx_name_score",
    "ranges": [
        "name84059 < name"
    ] /* ranges */,
    "index_dives_for_eq_ranges": true,
    "rowid_ordered": false,
    "using_mrr": false,
    "index_only": false,
    "rows": 26420,
    "cost": 31705,
    "chosen": true
}
```

   > 30435 是查询二级索引的 IO 成本和 CPU 成本之和，再加上回表查询聚簇索引的 IO 成本和 CPU 成本之和。

2. 使用 create_time 进行索引扫描需要扫描 27566 行，成本是 33080。

```json
{
    "index": "idx_create_time",
    "ranges": [
        "2023-04-15 13:00:00 < create_time"
    ] /* ranges */,
    "index_dives_for_eq_ranges": true,
    "rowid_ordered": false,
    "using_mrr": false,
    "index_only": false,
    "rows": 27566,
    "cost": 33080,
    "chosen": true
}
```

3. 全表扫描 100064 条记录的成本是 20366。

```json
{
    "considered_execution_plans": [
        {
            "plan_prefix": [
            ] /* plan_prefix */,
            "table": "`person`",
            "best_access_path": {
                "considered_access_paths": [
                    {
                        "access_type": "scan",
                        "rows": 100064,
                        "cost": 20366,
                        "chosen": true
                    }
                ] /* considered_access_paths */
            } /* best_access_path */,
            "cost_for_plan": 20366,
            "rows_for_plan": 100064,
            "chosen": true
        }
    ] /* considered_execution_plans */
}
```

所以 MySQL 最终选择了全表扫描方式作为执行计划。

把 SQL 中的 create_time 条件从 13:00 改为 15:00，再次分析 OPTIMIZER_TRACE 可以看到：

```json
{
    "index": "idx_create_time",
    "ranges": [
        "2023-04-15 15:00:00 < create_time"
    ] /* ranges */,
    "index_dives_for_eq_ranges": true,
    "rowid_ordered": false,
    "using_mrr": false,
    "index_only": false,
    "rows": 6599,
    "cost": 7919.8,
    "chosen": true
}
```

因为是查询更晚时间的数据，走 create_time 索引需要扫描的行数从 33080 减少到了 7919.8。这次走这个索引的成本 7919.8 小于全表扫描的 20366，更小于走 name_score 索引的 31705。

所以这次执行计划选择的是走 create_time 索引。

## 解决方案

有时会因为统计信息的不准确或成本估算的问题，实际开销会和 MySQL 统计出来的差距较大，导致 MySQL 选择错误的索引或是直接选择走全表扫描，这个时候就需要人工干预，使用强制索引了。

比如，像这样强制走 name_score 索引：

```sql
explain select * from person FORCE INDEX(name_score) where NAME >'name84059' and create_time>'2023-04-15 13:00:00'
```

## 小结

本文通过一个例子，谈到了 MySQL 还有另外一个索引失效的场景，即分析器成本分析。

对于是否走索引，我们要学会使用 explain 进行分析。另外，在 MySQL 5.6 及之后的版本中，我们可以使用 optimizer trace 功能查看优化器生成执行计划的整个过程。

> 整理自极客时间《Java开发常见错误》学习笔记
>
> 公从号：杨同学technotes